% DFF template for Latex and A4 paper.
% 12pt Times New Roman on 1.5 line spacing and 2 cm margins.

% ----------------------------------------------------------------------

% Either format with
%    pdflatex projectdescription.tex
% Or if you use dvips and ps2pdf, remember to specify A4 paper:
%    latex  projectdescription
%    dvips  -ta4 projectdescription -o projectdescription.ps
%    ps2pdf -sPAPERSIZE=a4 projectdescription.ps

% ----------------------------------------------------------------------

\documentclass[fleqn,12pt]{article}
\usepackage[a4paper,top=2cm,bottom=2cm,left=2cm,right=2cm]{geometry}
\usepackage{times}
\usepackage[danish,english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% \usepackage{graphicx}         % For PDF figures
% \usepackage[dvips]{graphicx}  % For EPS figures, using dvips + ps2pdf

\usepackage[colorlinks=true,linkcolor=black,citecolor=black]{hyperref}
\usepackage{booktabs}

\usepackage{tikz}
\usetikzlibrary{positioning,fit}
\usetikzlibrary{shapes,backgrounds}
\usetikzlibrary{arrows,fit,automata,positioning,decorations,calc}
\usetikzlibrary{spy}
\usetikzlibrary{matrix,chains,decorations.pathreplacing}
\usepackage{pgfgantt}

\newcommand{\code}[1]{{\textsf{#1}}}

% Adding comments in the text during writing process
\newcommand{\todo}[1]{{\it TODO: #1}}
\newcommand{\note}[1]{{\it Note: #1}}
\newcommand{\martin}[1]{{\color{blue} Martin: #1}}
\newcommand{\jens}[1]{{\color{green} Jens: #1}}

% uncomment following for final submission
%\renewcommand{\todo}[1]{}
%\renewcommand{\note}[1]{}
%\renewcommand{\martin}[1]{}
%\renewcommand{\jens}[1]{}




%%% ZF
\usepackage{listings}
\lstset{
	columns=fullflexible,
	%        basicstyle=\ttfamily\footnotesize,
	basicstyle=\ttfamily\small,      
	%columns=fullflexible, keepspaces=true,
	numbers=left,    
	numberblanklines=false,
	captionpos=b,
	%	breaklines=true,
	escapeinside={@}{@},
	numbersep=5pt,
	language=C,
	tabsize=2,
	breakatwhitespace=true,
	breaklines=true,
	deletekeywords={for},
	%        keywordstyle=\ttfamily
	numbersep=5pt,
	xleftmargin=.10in,
	%xrightmargin=.25in
}



\begin{document}
% Empirically this seems to match MS Word's idea of 1.5 line spacing.
% DO NOT CHANGE
\setlength{\baselineskip}{1.44\baselineskip}

% ----------------------------------------------------------------------
% Enter the title of the project and your name

\begin{center}
  {\LARGE\bf DFF Project Description }\\[1ex]
  %https://dtudk.zoom.us/j/61032875012
  {\LARGE\bf Software-Defined Hardware (SDH)}\\[1ex]
  {\large Martin Schoeberl, DTU Compute}\\[1ex]
 \end{center}

% ----------------------------------------------------------------------
% Delete the instruction

%\noindent
%The length of the project description must not exceed the number of pages indicated for the specific instrument in the Call, excl. a brief list of references, whether it includes figures/tables or not. \emph{You must use Times New Roman; 12 point font size; 1.5 line spacing; and with a right, left, top and bottom margin of at least 2 cm. The requirements for font size also apply to any footnotes, tables and figure texts.}  This template is formatted accordingly. In the "Confirmation" \ section of the application form, you must confirm that your project description observes the permitted maximum length, before you can submit your application. The Council will disregard any portions of the project description that exceed the permitted maximum length. 
%
%Please note that the summary of the project should only be included in the application form (under the section "Title and scientific content"). The summary should therefore not be included in the project description.
% Delete the instruction

% ----------------------------------------------------------------------
% Begin writing your project description

%\section{Abstract for the application -- do not include in this document}
%
%Performance increase with general-purpose processors has come to a halt. We can no longer depend on Moore's Law to increase computing performance. The only way to achieve higher performance or lower energy consumption is by building domain-specific hardware accelerators. These accelerators can be built in ASICs or in FPGAs in the cloud. To efficiently design and verify those domain-specific accelerators, we need agile hardware development.
%
%
%This project aims to develop a method and concrete tools for agile hardware development. We will use tools, languages, development, and testing methods from the last decades in software development and apply them to hardware design. We aim to raise the tooling level for a digital design to increase productivity. Time for verifying (testing) of digital systems is about double the time of developing them in the first place. Therefore, this project's central focus is on applying software development testing methods to hardware development.
%
%\subsection{Popular Abstract}
%
%Digital systems are a central part of our current and future digital enhanced live. Denmark has a considerable industry in the design and development of digital systems. However, designing and verifying such digital systems becomes an ever-growing challenge. The main issue is the usage of old tools compared to tools for programming those devices. This project aims to apply tools and methods from software development to hardware development to increase productivity. Danish firms will benefit from the results of this project.

\section{Introduction and Objectives}
\label{sec:objectives}

\todo{Deside on wording (HW, digital, testing, verification.)}


We can no longer depend on Moore's Law to increase computing performance~\cite{dark-silicon:2011}.
Performance increase with general-purpose processors has come to a halt.
The only way to achieve higher performance or lower energy consumption
is by building domain-specific hardware accelerators~\cite{domain-hw-acc:2020}.
These accelerators can be built in chips or in FPGAs in the cloud.
The production of a chip is costly. Therefore, it is essential to get
the design right at the first tape-out. Thorough testing and verification of the design is mandatory.

To efficiently develop and verify those accelerators, we can learn from software development trends such as agile software development~\cite{agile:manifesto}.
We believe that for the road ahead, we need to adapt to agile hardware development~\cite{henn-patt:turing:2019}.

\todo{Get the SW people in here or later}

\todo{Jan's comment: I think that it could be a good idea to link to FPGA's - we need to show that many will need this, not just a few exotic companies doing advanced ASIC. 
I my view, an important contribution is to make this field accessible to software designers and not just making hardware designers adapt SW development methods! Maybe this could be my angle/contribution to the project?}

Until a few years, the two main design languages Verilog and VHDL, dominated the
design and testing of digital circuits. However, both languages are decades behind
modern languages for software development.

Compared to software development and testing, digital design and testing methods
and tools lack several decades of development. Within this project we plan to
leverage software development and testing methods for digital design.
This project explores the hardware construction language Chisel with Scala
and the Universal Verification Method (UVM) with SystemVerilog for
design and test of digital systems.

Recent advances with SystemVerilog and Chisel \cite{chisel:dac2012, chisel:book} have brought object-oriented programming
into the digital design and verification process. SystemVerilog, an extension of Verilog, adds object-oriented concepts for the non synthesizable verification code.
Chisel is a ``Hardware Construction Language'', embedded in Scala, to describe digital circuits.
Circuits described in Chisel can be tested and verified with a Chisel testing framework and Scala tests.
Scala/Chisel brings object-oriented and functional programming into the world of
digital design.


\emph{Focus on and highlight: Our aim is to rise the tooling level for digital design to increase
the productivity.}

This project aims to develop a method and concrete tools for agile hardware development.
We will use tools, languages, development, and testing methods from the last decades in
software development and apply them to hardware design.
We aim to raise the tooling level for a digital design to increase productivity.
Time for verifying (testing) of digital systems is about double the time of developing
them in the first place.
Therefore, this project's central focus is on applying software development
testing methods to hardware development.


\todo{does the following fit? taken from the (paper) abstract} 
We will build a combination of open-source tools for verifying
circuits described in mixed languages. It builds on top of the Chisel
hardware construction language and uses Scala to drive the verification. 
We will explore the testing strategy used in the Universal Verification Methodology
(UVM) in the context of verifying hardware described in Chisel.


This project proposes a research project that aims at building a testing framework
in Scala that takes the best methods from UVM and from decades of experience
in software testing.
The developed framework shall support mixed languages (VHDL, SystemVerilog, and Chisel)
to be able to integrate legacy code.
Furthermore, our aim is to build on open-source projects. Therefore, our
work will be in open-source as well.

\begin{itemize}
\item See for arguments: \url{https://cacm.acm.org/magazines/2020/7/245701-domain-specific-hardware-accelerators/fulltext}
\item Maybe more ideas: \url{https://www.youtube.com/watch?v=dbOi_Gboi_0}, \url{https://www.youtube.com/watch?v=4FCZLrauDcE}
\item Have a measurable objective (LoC UVM vs Scala, SystemVerilog vs Chisel)
\item Chisel has all the Scala/Java tooling and libraries available, SystemVerilog is a niche language
\item Rise level of tooling, not necessarily level of abstraction in HW description
\item IDE
\item Namespace with packets make it easier to combine IPs
\item With Maven it is easy to combine open-source IPs
\item Industry issue is verification: how from Chisel to VHDL/Verilog
\item How much ASIC design is done in DK? Revenue numbers?
\item There are not enough HW designers and verification engineers available, so they shall be more productive
\item Or we can attract SW developer with Chisel to do HW design
\item Future cloud server will include FPGA for application speedup, how to program them
\end{itemize}

\section{Background and State-of-the-Art}
\label{sec:background}


\subsection{Hardware Design and Verification}

\begin{itemize}
\item Verification (check what is current praxis)
\item cocotb
\item See pull request for ref to constraint random generation
\item In classic HDL tooling (language, IDE, test infrastructure) is very bad
\item SV as language has 250 keywords!
\item Related work \url{http://koo.corpus.cam.ac.uk/drafts/tndjg-008-transactional-modelling-in-chisel.html}
\item SV OOP is not available for synthesize, functional coverage, another test case could be my S4NOC, reference models are usually written in SystemC to avoid licenses cost for the SW developer
\end{itemize}

The SystemVerilog DPI / Direct Programming Interface allows the programmer to call
C functions from inside of a SystemVerilog (UVM) testbench.
This enables co-simulation via eg. a "golden model" written in C and the
testbench verifying the DUT.

The Java JNI (Java Native Interface) allows for a similar functionality in Java programs,
allowing them to call C functions and use their functionality.
By using Scala, which is built on Java, it is our hope to use the JNI together with Scala's test frameworks.
The aim is to develop a framework for co-simulation with Scala/Chisel testers and a
C-based golden model. This should allow companies to keep their existing C models,
but move their simulation workflow into Scala/Chisel testers.


%%%ZF
\subsection{Software Testing Methods}
Testing is crucial for making software reliable. The higher
expectation of software quality and shrinking development cycle have
driven programming language researchers and software engineers to
develop a spectrum of \emph{automated testing} techniques. For example,
Continuous Integration~\cite{duvall2007continuous} implements an agile
method based on expert-written unit tests. It runs the tests
automatically during software evolution to avoid regression.  However, continuous integration automates only execution
of tests, not their generation. To deal with the later,
state-of-the-art automated testing research addresses
the following two challenges.


\paragraph{Determining Specification.}
The first challenge is how to determine the expected code outcome, or
called \emph{specification}.  Software developers often document
specification within software itself.  \emph{Property-based testing}
provides a convenient way in formulating specification as constraints
expressed in a domain-specific
language~\cite{DBLP:conf/icfp/ClaessenH00}.  For example, developers
in the Scala language can specify ``$n^2>0$ for all integers'' in the
property-based testing library ScalaCheck~\cite{nilsson2014scalacheck}
as follows:
\begin{lstlisting}[numbers=none]
val propSquare = forAll {(n: Int) => n * n > 0}
\end{lstlisting}
An efficient approach to obtain such specification is to learn from
historical bug patterns. Such patterns are gathered in pattern-based
software analysis tools, {\em e.g.}, in
FindBug~\cite{DBLP:conf/paste/AyewahPMPZ07} or
Scalafix~\cite{web:scalafix}.  Recently, specification for robotic
software is obtained by studying bugs fixed on the GitHub of Robot
Operating System~\cite{nielsenFSW2020dependencybugs}.





%% ZF. This is commeented out because we have decided to not write on
%% the WP related to sanitizers.

%% Another way to generate specification is to use \emph{sanitizers}
%% in compilers. Sanitizers are a common compiler feature that
%% automatically injects run-time checks to capture certain failure
%% conditions~\cite{DBLP:conf/usenix/SerebryanyBPV12}. For example,
%% Google's undefined behavior sanitizer UBSAN checks whether a
%% floating-point variable equals 0 before a division by it; Google's
%% address sanitizer ASAN targets illegal memory access. While
%% sanitizers do not deal with functional correctness as unit tests
%% do, they check low-level, sometimes security-related properties,
%% such as use-after-free, array-index-out-of-bound, or race
%% conditions.

\paragraph{Generating Test Inputs.}
The second challenge is how to generate interesting tests inputs.  The
state-of-the-practice uses \emph{fuzzing}, which has emerged as one of
the most effective testing techniques for discovering reliability
issues in software~\cite{takanen2018fuzzing}.  Google's OSS-Fuzz
project, for example, has filed over 20 000 bugs in 300 open-source
projects (as of June 2020)~\cite{web:oss-fuzz}.  Fuzzing techniques
generate random inputs and improve them based on observed code status,
\emph{e.g.}, crashes or code
coverage~\cite{DBLP:journals/tse/BohmePR19,DBLP:conf/pldi/FuS17}.
Property-based testing~\cite{DBLP:conf/icfp/ClaessenH00}, which is
initially designed for testing functional programming languages, uses
random data generation, a form of plain fuzzing. For example, by
invoking {\tt propSquare.check} with ScalaCheck (mentioned above), where {\tt
  propSquare} is the constraint $n^2>0$ for all integers $n$, we can
immediately get an input $n$ that falsifies the constraint:

\begin{lstlisting}[numbers=none]
scala> propSquare.check
       ! Falsified after 1 passed tests.
      > ARG_0: 0
      > ARG_0_ORIGINAL: 1083860448
\end{lstlisting}
 ScalaCheck first finds that n = 1083860448 produces an overflow
 wrapped to a negative (thus $n^2>0$ fails). The input is then
 "shrunk", in the terminology of property-based testing, to a smaller
 one, namely 0 in this case.







\section{Research Plan}


%%%ZF





%\subsection{WP1}
As prerequisites, students involved in this project will need to learn
about tools involved in the project and related work in the state of
the art. On the software side, they will learn about the 
Scala programming language, and ScalaCheck (a Scala implementation of
the property-based testing). On the hardware side,
the students will need to get familiar with Chisel, SystemVerilog and
UVM.



%\subsection{WP2}
\paragraph{Property-based Testing.}
As a starting point, we will use ScalaCheck, an implementation of
property-based testing in Scala, for hardware testing. We will invite
hardware developers to write properties as constraints (like
propSquare above), and then we will use ScalaCheck to validate or
refute those constraints. Property-based testing has seen notable
successes previously, such as in locating a long-standing concurrency bug
in the Erlang database server; it was also used by Volvo to test car
communications protocols~\cite{DBLP:conf/icse/HughesNSA16}.

\paragraph{MS1.} The milestone is to have a empirical study on the effectiveness of our approach. In particular,  we will consider testing  two kinds of properties. The first kind is injected faults, of which we will measure our capability in detecting the faults. Another category is the expected code behavior, on which our approach should  pass without raising  warnings. 

\paragraph{Co-simulation.}

\todo{A figure would be nice.}

\begin{itemize}
\item One use case for evaluation: cosimulation of a RISC-V simulator (Tommy) with an OS RISC-V HW 
\item Ptolemy~\cite{ptolemyII-book} can be used to co-simulate the environment, supporting a model based design.
\item Integration of C/C++ based models in the verification with Scala
\item Java/Scala in UVM
\item Hw/sw co-verification with Scala and so on, e.g., run an application on a SW processor model exploring some hardware artifacts (could be S4NOC)
\item Model based design (Jan) with co-simulation
\end{itemize}

\paragraph{Assertions.}

\begin{itemize}
\item assertions during simulation
\item Assertion ave been long part in SW, begin of C, but seldom used in HW and more complex assertions are interesting, such as when req is asserted, an ack has to become active within 5 clock cycles
\end{itemize}

\paragraph{Constraint Random Testing.}

\begin{itemize}
\item xxx
\end{itemize}


\paragraph{Test Coverage.}

\begin{itemize}
\item Code coverage can be a very useful tool when it comes to the verification of digital systems, since it allows one to see which parts of their design have actually been tested correctly. 
This has lead us to want to implement coverage inside of the FIRRTL execution engine Treadle using a technique presented by Ira. D. Baxter in the paper entitled “Branch Coverage for Arbitrary Languages Made Easy"~\cite{branch-cov-made-easy:2002}. Treadle, at the start, did not contain any tools pertaining to test coverage, but now we have added branch coverage to it so that one can see which lines of LoFIRRTL code (the intermediate representation used inside of Treadle) were covered by a series of tests and then know, using that information, which multiplexer paths were tested. 
The idea now would be to map the results obtained with LoFIRRTL code back to the source Chisel description. This mapping can be done using treadle’s internal “source trackers” that associate some FIRRTL lines back to their chisel source. Once that is done, it could be interesting to move from branch coverage to functional coverage, which would require a way to define \textit{functional coverage points} also known as \textit{coverage groups} in SystemVerilog.
\item On coverage and cover points in proposal (coverage of the RTL hardware, but also on the generator (Jack's comment, see \url{https://gitter.im/freechipsproject/chisel3?at=5f63c878603d0b37f43b67f3})
\end{itemize}

\paragraph{Framework.}

\begin{itemize}
\item Bus functional models
\item Multiple languages
\item Still talk about a small example taking it through all variations
\item WP on VHDL generation from Chisel for better verification
\item p69: HDL models are SW projects

\end{itemize}

\begin{itemize}
\item xxx
\end{itemize}



%% Let us consider this one below as a bonus WP in our backyard.
%% \subsection{WP2} 
%% We can then consider to generate specification automatically, \`a la
%% sanitizers used in the compiler techniques. This WP focuses on
%% low-level properties derived from the program syntax, {\em, e.g.},
%% accessing an array should be within a bound, or performing an
%% arithmetic calculation should not overflow.



%% \paragraph{MS2.} The milestone in this WP is to develop a program transformer
%% that injects in the software source, or its binary form, a list of
%% low-level specifications.

%% Related to this WP, our project collaborator Zhoulai Fu (together with
%% a hired security hacker) used sanitizers to find more than 200 bugs in
%% the Robot Operating System
%% (ROS)~\cite{web:ros-sanitizer-logs}. Besides, Zhoulai Fu has developed
%% several program transformers previously for testing floating-point
%% computation~\cite{DBLP:conf/pldi/FuS19,DBLP:conf/oopsla/FuBS15}.



\paragraph{Learning Specification from Historical Bug Patterns.}
we will consider generating specification from previous known bug
patterns.  We will collaborate with our hardware engineers to explore
a history of hardware issues triggered by software defects, and get
patterns from winch we generate specification.  Such bug patterns in
Java, for example, can be found in \cite{web:findbugs_bugs}.  This
step will generate specification in a syntax-driven way, relating to
expected functional behavior of the hardware.




\paragraph{MS2.} We will create  a database from historical  bug patterns. A program transformer will be implemented to convert the bug patterns
into code specification. The generated specification for our benchmark
should be validated by our hardware developers, with which a
refinement step can be introduced to improve the database.


%% Related to this, our collaborator Zhoulai Fu has worked on a
%% comprehensive study of developing bug finders by learning from history
%% bug patterns in the Robot Operating
%% System~\cite{nielsenFSW2020dependencybugs} .



\paragraph{Fuzzing Techniques.}
Once we have tools to instrument the software under test with user-written
specification or automatically generated specification, we will be in a position of using fuzzing techniques
to validate those specifications. To this end, we will need to work
with our industrial collaborators to get access to driver programs
that runs the software under test.

\paragraph{MS3.} The milestone  is to have a list of bugs reported, and a detailed case study (whether the bugs are
trivial, false alarms, for example) Besides, coverage statistics will
be collected to measure comprehensiveness of our tests.


%% Let us consider this as another backyard WP.
%% \subsection{WP5} We plan to deploy our automated testing solution  in a continuous
%% integration service, presumably on the cloud, such as Jenkins or
%% Travis~\cite{DBLP:journals/tse/GallabaM20}. For each code commit, the
%% service will automatically generate the specification as implemented
%% in WP2 and WP3, and then will generate test data with a fuzzing engine
%% as in WP4.

%% \paragraph{MS5.} The milestone is to have the server established that implements
%% the workflow. It should produce a detailed status report for each
%% commit.  A similar kind of status report can be found in Google's
%% OSS-Fuzz (Continuous Fuzzing for Open Source
%% Software)~\cite{web:oss-fuzz} for example.


\paragraph*{Dissemination and Publication}

Scientific results will be published and presented at international
conferences (e.g., DATE, DAC, CAV, FPL, ISCAS, FPGA) and in relevant scientific journals.
We expect that most tasks will result in at least one publication.
One PhD theses will publish the results from the project.
We aim to publish in open access, to a large extent in the gold open access model.
However, publishers such as ACM also allow publishing in green open access
at no additional cost, where a pre-print version of a paper can be uploaded,
for example, to ArXiv.

The results from the project will be available as open-source under the
industry-friendly BSD license.
%Open-source research projects attract
%other researchers, developers, and industrial partners
%to use and build on the results of the project.
A project web site will host the project documentation, the published papers, and the
source code of the design.

\begin{itemize}
\item Chisel design and verification workshops including hands-on tutorial in DK, at IDA, have an ok letter from them
\end{itemize}


\emph{From the call: DFF finds it important to strengthen the societal effect of research by ensuring unrestricted and cost free digital access}



\section{Practical Feasibility}

%The Embedded Systems Engineering section at DTU Compute provides
%the intellectual environment and the infrastructure (e.g., regression test server...) that we need for an ambitious research project.
%Furthermore, DTU Compute provides the infrastructure (e.g., an automatic test
%environment for regressions tests, web server).

\paragraph*{Internationalization}



\paragraph*{Industrial Cooperation}

Teledyn is interested in the development of ... \todo{write the stuff..}

\begin{itemize}
\item Use industry partners use cases
\end{itemize}


\paragraph*{Use Cases}

We will have several non-trivial use cases from industry and from our own development to verify
our development. \todo{Industry first}
From our research we will use a multicore device, a network-on-chip~\cite{s4noc:nocarc2019},
to explore concurrent, transaction based verification.

\paragraph*{Human Resources}

For the SDH project we request funding of two PhD students and a student researcher.
Each of the senior researchers will contribute to the SDH research project.
%
%We intend to build a group with one PhD student, one postdoc, and
%two senior researchers at DTU.
%
%Quoted from the Diversity and Gender statement at DTU:
%``Diversity, equal treatment, and equality are integral to DTU, being an international
%university in scope and standard, and are fundamental principles underlying DTU's
%expectations of respect and equality''.
As the already named researchers are all male, we will actively search
for female researchers for the PhD positions.
However, the PhD position will be announced openly and men and women
will have equal opportunities for applying.


{\bf Martin Schoeberl (MS)} is associate professor at DTU Compute and is the PI.
His research interest is in computer architecture for real-time systems. During his stay
at UCB in 2012 he picked up Chisel and brought it to DTU in research and teaching.
Martin has written the Chisel textbook~\cite{chisel:book}, which has been translated
to Chinese and Japanese. Martin is member of the Technical Advisory Committee for
Chisel and therefore keeps the work of SDH in sync with the Chisel main development.

\todo{fill in stuff}

{\bf Jan Madsen (JM)} 

{\bf Kasper Hesse (KH)} is student at DTU with a strong background in digital design.
He has already some knowledge in UVM and can therefore help the project to be productive
from day one.

{\bf Zhoulai Fu (ZF)} is an assistant professor at ITU. His research
spans programming language theory and software engineering
techniques. Related to this project, he worked on developing
constraint solving and automated testing techniques in achieving high
coverage and detecting bugs in numerical programs.

{\bf Peter Sestoft (PS)} 

{\bf NN PhD (NN1)} 

{\bf NN PhD (NN2)} 


%\subsection*{Experimental Facilities}
%
%Development and simulation of the RTAI hardware can be
%performed on standard desktop PCs.
%For evaluation of individual design components small and cheap FPGA
%boards, that are already available, can be used. For the evaluation of the
%full system design of a switches with ANNs, we intend to buy three high-performance
%FPGA boards.
%%
%The needed software (e.g., VHDL simulation, FPGA compilation) is freely available.


%\vspace{-2mm}
\begin{table*}% [h!]
{\small
  \begin{center}
    \begin{tabular}{lccp{110mm}l}
      \toprule
      Task          & PM  & Person &  Description \\
      \midrule
      Recruiting  & 1 & MS and ZF & Recruiting of the two PhDs \\
      \midrule
      uvm     &  9      & KH     & Develop a UVM verification example on a complex multicore device, a network-on-chip.\\
      xxx     &  6      & HP     & .\\
      xxx    &  9      & HP     & .\\
      xxx     &  6      & HP     & .\\
      \midrule
      SOA  & 3      & PhD1     &  . \\
      xxx  & 6      & PhD1     &  . \\
      xxx  & 6      & PhD1     &  . \\
      xxx  & 3      & PhD1     &  . \\
      xxx  & 6      & PhD1     &  Implement . \\
      xxx  & 6      & PhD1     &  Implement . \\
      \midrule
      Explore   &    2x6 & PhD1/2    &  .\\
      Eval & 2x6 & PhD1/2 & Evaluation of the results collected with. \\
      Thesis & x & PhD1/2 & Thesis writing und submission.\\
      \midrule
      Chapter & 2 & MS & Adding a chapter on verification to the Chisel book~\cite{chisel:book}. \\
      \bottomrule
    \end{tabular}
  \end{center}
%  \caption{Work packages}\label{tab:packages}
}
\end{table*}

%\vspace{-5mm}
\paragraph*{Tasks, Milestones, and Timetable}

The project is divided into several tasks.
%A researcher will be
%assigned to each task as its main developer.
%A cooperative
%working style will be encouraged so, that the experience and
%knowledge of the different team members will optimally be utilized.
For each task, the time is given in person months (PM). The Gantt chart shows
the project schedule.
For an assessment of the project's success we plan following milestones:

\textbf{M1} (Month 6): The PhD student is selected and employed.

\textbf{M2} (Month 15): Two versions ...

\textbf{M3} (Month 30): All development has been finished and the different versions
can be used for exploration and evaluation of the results ...

\textbf{M4} (Month 48): The project has finished and two PhD theses have been handed in.

%\vspace{-5mm}
\begin{figure*}[h!]
\centering
\begin{ganttchart}[vgrid,hgrid,bar/.style={fill=gray},
x unit=3mm, % horizontal squeezing
%y unit chart=5mm, % vertical squeezing
y unit title=8mm,y unit chart=4.5mm, milestone top shift=.15, milestone height=.2mm, % very tight format
title label font=\footnotesize,
bar label font=\footnotesize,
milestone label font=\footnotesize,
]{1}{48}
% labels
%\gantttitle{\textbf{\normalsize{RTAI Gantt chart}}}{42} \\
\gantttitlelist{1,...,48}{1} \\
% tasks, groups and milestones
\ganttbar[name=r1]{Recruting}{1}{6} \\
\ganttmilestone[name=m1]{Milestone 1}{6} \\
\ganttbar[name=t1]{xxx}{1}{9} \\
\ganttbar[name=t2]{xxx}{10}{15} \\
\ganttbar[name=t3]{xxx}{16}{24} \\
\ganttmilestone[name=m2]{Milestone 2}{15} \\
\ganttbar[name=t4]{xxx}{25}{30} \\
\ganttbar[name=t5]{SOA}{7}{9} \\
\ganttbar[name=t6]{vvv}{10}{15} \\
\ganttbar[name=t7]{vvv}{16}{21} \\
\ganttbar[name=t8]{vvv}{22}{24} \\
\ganttbar[name=t9]{vvv}{25}{30} \\
\ganttmilestone[name=m3]{Milestone 3}{30} \\
\ganttbar[name=t10]{Explore}{31}{36} \\
\ganttbar[name=t11]{Eval}{37}{42} \\
\ganttbar[name=t12]{Thesis}{40}{48} \\
\ganttbar[name=t13]{Chapter}{40}{46} \\
\ganttmilestone[name=m4]{Milestone 4}{48}

% relations
\ganttlink{r1}{m1}
\ganttlink{t1}{t2}
\ganttlink{t2}{m2}
\ganttlink{m2}{t3}
\ganttlink{t3}{t4}
\ganttlink{t4}{m3}

\ganttlink{m1}{t5}
\ganttlink{t5}{t6}
\ganttlink{t6}{m2}
\ganttlink{m2}{t7}
\ganttlink{t7}{t8}
\ganttlink{t8}{t9}
\ganttlink{t9}{m3}
\ganttlink{m3}{t10}
\ganttlink{t10}{t11}
\ganttlink{t11}{m4}
\ganttlink{t12}{m4}
\ganttlink{t13}{m4}

\end{ganttchart}

\caption{The Gantt chart of SDH}\label{fig:gantt}
\end{figure*}




%\vspace{2mm}

\newpage
\small
\bibliographystyle{abbrv}
%\bibliography{myown,jsp,noc,misc,msbib}
\bibliography{../msbib,testing}

\newpage

\section{Ideas, Questions, TODOs}



\begin{itemize}
\item Include proposal from Jesper Birch (in Word document)
\item Take material from workshop paper
\item Look at the TODO list in infinit project
\item Widex is interested in Chisel, may join a DFF proposal
\item Peter Syst + microsoft cloud into Chisel project
\item DeepSpec or DeepSp?? end-to-end for Chisel
\item Support letter from UCB
\item External stay at UCB
\item Richard should be part of it
\item One PhD at ITU and PhD or postdoc (Lefteris at DTU)
\item Kasper n hours per week plus maybe part time Torur
\item Thomas from Microsemi on board
\item Konstantin Vinogradov <const.vin@gmail.com> from Widex is interested in a (industrial) PhD, might be a named candidate
\item Teledyn is interested
\end{itemize}

\subsection{Contacts}

%Jesper Birch <jb@napatech.com> sent a word document and is interested.
%
%Teledyne:
%
%"Rytter, Morten (INT)" <Morten.Rytter@Teledyne.com>
%
%simon.andersen@teledyne.com
%


One option would be for us to deliver test cases and discussions of what is needed for our company. 



\subsection{TODO}

Send proposal draft proposal and of August to Jesper, Thomas, ...

\section{From InfinIT}

Digital systems are already an integral part of our life. These systems are built out of microprocessors, application specific integrated circuits (ASICs), and field-programmable gate arrays (FPGAs). Several companies in Denmark are building digital systems. To increase competitivity of those companies, we need tools and methods to increase the productivity in designing and especially testing digital systems. Compared to software development and testing, digital design and testing methods and tools lack several decades of development. Within this project we plan to leverage software development and testing methods for digital design. This project explores the hardware construction language Chisel with Scala and the Universal Verification Method (UVM) with SystemVerilog for design and test of digital systems.



UVM is becoming an industry standard for design verification. On the other hand there is an active development on a new hardware construction language, called Chisel. Chisel is embedded in Scala to write so-called hardware generators. Chisel is also called: software defined hardware. Another feature of the Chisel/Scala combination is to write models of the environment of the hardware design in Scala. As an example take a network interface (e.g., Ethernet) written as a high-level model in Scala connected to a microprocessor written in Chisel. With this example we are able to develop and test network code on the microprocessor, which is our digital design under test.



As a first step we will explore and compare the two approaches: UVM/SystemVerilog and Chisel/Scala. When we generate hardware from Chisel, we generate a Verilog description of the digital circuit. This Verilog description can further be tested within UVM (plain Verilog is valid SystemVerilog). As a next step, we will explore how test, simulation, and verification code written in Scala to develop the Chisel description of the digital circuit can be reused at the UVM level to test the generated Verilog description of the circuit.


Modern software techniques can be applied on testing where plausible. For example, fuzzing is a mature solution for producing random and yet meaningful inputs to trigger program failures. Symbolic execution explores program paths systematically via constraint solving.



We are in contact with the developers of Chisel at the University of California in Berkeley, and especially with Richard Lin, who is developing the new testing framework for Chisel. Richard is interested in this project and the integration with UVM. Therefore, we agreed to have a cooperation meeting during the project at UC Berkeley.



The project fits into the Infinit topic of IoT. The things of IoT are digital systems, often small and application specific systems. Application specific systems are built out of digital systems either with a dedicated ASIC or an FPGA.



This mini-project will be executed in close cooperation with Microchip, WSA, Synopsys, and Syosil. 



The students involved in the research project well then be well educated future engineers for digital system design and verification.



3. Aktiviteter (beskriv) 1. Learning and exploring SystemVerilog/UVM (with Synopsys)
2. Learning and exploring Chisel/Scala
3. Defining two use cases together with Microchip
4. Developing the two use-cases in Chisel and SystemVerilog with a comparison
5. Developing the verification environment including high-level models of the environment in UVM and Chisel/Scala with a comparison
6. Application of the UVM verification of the Chisel generated Verilog code
7. Scala based testing and verification on top of UVM
8. Develop an open course on verification of digital systems for DTU and use in industry




4. MilestonesKnowledge of the tools30/4/2020Definitions of the use cases31/5/2020Use cases developed30/7/2020Verification and high-level models developed31/8/2020Cross verification from Scala to UVM functional, course material finalize31/10/2020

5. Deltagere



DTU, CVR-nr. 30 06 09 46, Martin Schoeberl (project lead) (masca@dtu.dk) and Jan Madsen (jama@dtu.dk)
DTU will develop the use cases and the verification environment with UVM and Chisel/Scala. DTU will transfer knowledge on Chisel to Microchip and WSA.
ITU, CVR-nr. 29 05 77 53, Peter Sestoft (sestoft@itu.dk) and Zhoulai Fu (zhfu@itu.dk)
ITU will apply methods from software testing to digital hardware verification.
Aarhus Universitet, CVR-nr: 31119103, Farshad Moradi (moradi@eng.au.dk)
AU will explore UVM verification of Chisel generated Verilog code.
Microchip Semiconductor Corp. A/S, CVR-nr. 24224694, Thomas Aakjer (Thomas.Aakjer@microchip.com)
Microchip will provide use cases for the research in design and verification where DTU can explore Chisel with Scala.
WS Audiology Denmark A/S, CVR-nr. 40296638, Ketil Julsgaard (ketil.julsgaard@wsa.com)
WSA will provide digital-signal processing use cases for cosimulation of a Chisel description with a high-level description.
Synopsys, CVR-nr. 25600568, Martine Chegaray (Martine.Chegaray@synopsys.com)
Synopsis will provide the tools for UVM for the project and guide the usage.
Syosil Aps, CVR-nr. 29399417, Jacob Sander Andersen (jacob@syosil.com)
Syosil will support the researchers with education in using UVM.


6. Resultater og vision for 

The vision of the project is a highly productive method for designing and (more importantly) verification of digital systems by a combination of the modern hardware construction language Chisel/Scala with the industry standard UVM.
7. Videnspredning

The research work will be documented by publications and presented at relevant conferences (for example DATE), funded by other means, not by this project.

At the end of the project we will present the method at a workshop open for Danish industry in digital system design.

The new development and verification method will be used and taught in courses on digital electronics at DTU.

\end{document}
