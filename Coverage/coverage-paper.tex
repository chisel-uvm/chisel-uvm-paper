\documentclass[conference]{IEEEtran}

\usepackage{cite}
\usepackage{pslatex} % -- times instead of computer modern, especially for the plain article class
\usepackage[colorlinks=false,bookmarks=false]{hyperref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{comment}
\usepackage{listings}

\usepackage{xspace}		% For using \SV with trailing spaces
\usepackage{cleveref}	% Needed for correctly referencing listings

\newcommand{\code}[1]{{\small{\texttt{#1}}}}
\newcommand{\SV}{SystemVerilog\xspace}


% fatter TT font
\renewcommand*\ttdefault{txtt}
\newcommand{\todo}[1]{{\color{olive} TODO: #1}}
\newcommand{\martin}[1]{{\color{blue} Martin: #1}}
\newcommand{\simon}[1]{{\color{green} Simon: #1}}
\newcommand{\abcdef}[1]{{\color{red} Author2: #1}}
\newcommand{\rewrite}[1]{{\color{red} rewrite: #1}}
\newcommand{\ducky}[1]{{\color{orange} Richard: #1}}
\newcommand{\kasper}[1]{{\color{purple} Kasper: #1}}

% uncomment following for final submission
%\renewcommand{\todo}[1]{}
%\renewcommand{\martin}[1]{}
%\renewcommand{\simon}[1]{}
%\renewcommand{\kasper}[1]{}
%\renewcommand{\ducky}[1]{}


%%% ZF
\usepackage{listings}
\lstset{
	columns=fullflexible,
	%        basicstyle=\ttfamily\footnotesize,
	basicstyle=\ttfamily\small,      
	%columns=fullflexible, keepspaces=true,
	numbers=left,    
	numberblanklines=false,
	captionpos=b,
	%	breaklines=true,
	escapeinside={@}{@},
	numbersep=5pt,
	language=C,
	tabsize=2,
	breakatwhitespace=true,
	breaklines=true,
	deletekeywords={for},
	%        keywordstyle=\ttfamily
	numbersep=5pt,
	xleftmargin=.10in,
	%xrightmargin=.25in
}

\newcommand{\longlist}[3]{{\lstinputlisting[float, caption={#2}, label={#3}, frame=tb, captionpos=b]{#1}}}

\bibliography{./coverage}

\title{Improving the Verification Efficiency of Chisel Designs with Multi-Level Code Coverage}

\author{\IEEEauthorblockN{Andrew Dobis, Enrico Tolotto, Hans Jakob Damsgaard, Martin Schoeberl}\\
\IEEEauthorblockA{\textit{Department of Applied Mathematics and Computer Science} \\
\textit{Technical University of Denmark}\\
Lyngby, Denmark \\\\
andrew.dobis@alumni.epfl.ch, s190057@student.dtu.dk, s163915@student.dtu.dk, masca@dtu.dk}
}


\begin{document}

\maketitle \thispagestyle{empty}


\begin{abstract}
Ever-increasing performance demands are pushing hardware designers towards the use of domain-specific accelerators. This means that more and more hardware must be designed from scratch in an ever shortening amount of time. We must thus find a way to improve the overall efficiency of the hardware design and verification cycles. The design efficiency was improved with the introduction of Chisel, however we still need to improve the verification efficiency. That is why we propose, in this paper, multiple solutions for adding one of the most important verification tools there is: code coverage. 

We explored and created methods to be able to obtain Statement coverage of a Chisel design at multiple levels of abstraction: at the Verilog, FIRRTL and Scala levels. The Verilog statement coverage is obtained by hooking into verilator and extracting the coverage results. The FIRRTL statement coverage is done by modifying the Treadle execution engine and running a custom FIRRTL compiler pass that adds coverage-gathering outputs to the generated AST in order to obtain information about the executed paths. Finally the Scala coverage is obtained using software coverage gathering tools found in the ScalaTest library. After exploring the potential statement coverage solutions, we move on to presenting our own Scala-implemented solution for gathering functional coverage on a Chisel design.  

We then finish off by presenting an industry-provided use case that illustrates the efficiency of our coverage tools. These solutions give the verification engineer ample ways to gather coverage on a Chisel design at any abstraction level. Note that a discussion could be had on the usefulness of coverage information at certain levels of abstraction (i.e. high-level coverage might not be interesting when using hardware generators), but for now this is left up for the reader to decide.
\end{abstract}

\begin{IEEEkeywords}
hardware verification, code coverage, SystemVerilog, Chisel, Scala, FIRRTL
\end{IEEEkeywords}

\section{Introduction and Objectives}
\label{sec:objectives}
As time passes, contemporary hardware design is met with tighter and tighter time constraints. This is added to the fact that, with the halting of Moore's law, hardware designers are turning to domain-specific accelerators in order to keep up with the ever-increasing performance demands~\cite{henn-patt:turing:2019}. This means that more and more hardware must be designed from scratch in shorter and shorter time periods~\cite{domain-hw-acc:2020}. However, the most widely used hardware description languages (i.e. VHDL and Verilog) are completely outdated and inefficient. To solve said problem, researchers at the University of California in Berkeley proposed Chisel~\cite{chisel:dac2012}, a Scala embedded high-level hardware construction language.

This solution is great, but is still lacking in verification functionalities and one of the main tools needed for the verification of digital systems is Code Coverage. This allows verification engineers to measure their progress throughout the testing process and have an idea of how effective their tests actually are. Coverage can be separated into multiple distinct categories, but we will focus on the following two: Statement and Functional coverage. Statement Coverage defines a quantitative measure of the testing progress, \textit{"How many lines of code have been tested?"}, whereas Functional Coverage gives a rather qualitative measure, \textit{"How many functionalities have we tested?"}~\cite{spear2008systemverilog}.

In this paper we will propose three different methods for obtaining statement coverage, each at different levels of abstraction. We will present these methods in a bottom-up fashion: first off we will talk about obtaining statement coverage of the Verilog description generated by Chisel, secondly we will show our solution for getting statement coverage of the FIRRTL intermediate representation and finally we will talk about getting coverage directly at the Scala level. Once that is done we will also present our solution for gathering functional code coverage of the Chisel design directly in Scala. In the following section we will take a brief look at the Chisel hardware construction language, how FIRRTL comes into play and gather the knowledge needed to fully appreciate our solutions.

\section{Background and State-of-the-Art}
\label{sec:background}
We will begin our brief overview by presenting Chisel and all of the tools surrounding it.
\paragraph{Chisel} Chisel is a hardware construction language embedded in the functional and Object-Oriented Programming (OOP) language Scala~\cite{scala:2006}. This means that a Chisel design actually generates a Verilog description that can then be synthesised. The language itself has syntax rooted in Scala, since Chisel is technically Scala code. This thus allows the description of hardware in a high-level manner, which is thus much for efficient than traditional HDLs like VHDL or Verilog. Scala also allows for both functional and OOP constructs, which makes it possible to organise a design implementation very intuitively using Scala classes and objects and also to use the power of higher order functions to greatly simplify descriptions thanks to constructs like \textit{mapping} or \textit{reductions}.
\paragraph{FIRRTL} In modern a Chisel design, the source code is first compiled into an intermediate representation that is used as a sort of "optimisation layer" before being converted into the final Verilog form. During this optimisation process the origin Chisel description goes through three different intermediate representation layers:
\begin{itemize}
\item High-FIRRTL, which is a form that maps perfectly back to chisel, but with the firrtl structure.
\item Mid-FIRRTL, which is a form where abstract constructs are simplified, i.e. loops are unrolled and arrays are flattened.
\item Low-FIRRTL, which maps perfectly to RTL code with high-level conditional statements turned into multiplexers.
\end{itemize}
Throughout this optimisation process, custom FIRRTL compiler passes, known as \textit{Transforms} can be used to modify the design. This is often done when trying to apply simplifications to the design to make the generated hardware more optimal~\cite{firrtlTechRep2016}.
\paragraph{Code Coverage} In software development, code coverage is used as a metric to measure the completeness of a testing suite. In recent years, these techniques, originally used for software, have been brought into the hardware verification universe in an attempt to reduce post-printing errors. The coverage metric can be defined in multiple ways, but in this paper we will mostly focus on two key aspects of it: Statement Coverage and Functional Coverage.

\textbf{Statement Coverage.} When wanting to retrieve coverage information about a specific program or design implementation, statement coverage will give us a quantitative measure of our testing progress. It measures which percentage of individual statements in our code have been tested. This metric can be very useful in the software world, when it comes to completeness of a testing suite, however it is only a partial solution in the hardware world, since it only tells us which lines were tested and not how well they were tested.  

\textbf{Functional Coverage.} If we are looking to measure the completeness of a test suite, we can not forget to ask the following question: "are we even testing the right thing?". In the hardware world, engineers usually implement designs based off of pre-determined specifications, so when testing, we should also have a metric for how well we are implementing the specification. This is where Functional Coverage comes in. The idea is to first define what is called a \textit{Verification Plan}~\cite{spear2008systemverilog}, which is supposed to represent the specification we are trying to implement. Once that is done, we can then sample the different points defined in our specification during the testing process, to obtain results in the form of: \textit{"test suite T covered a total of x\% of the values specified by point P in specification A"}. This was first implemented in SystemVerilog, in which a verification plan was defined using the following constructs:  
\begin{itemize}
\item \texttt{Bin}: Defines a range of values that should be tested for (i.e. what values can we expect to get from a given port).
\item \texttt{CoverPoint}: Defines a port that needs to be sampled in the coverage report. These are defined using a set of bins.
\item \texttt{CoverGroup}: Defines a set of \texttt{CoverPoint}s that need to be sampled at the same time.
\end{itemize}
Our solution tries to mimic this verification plan syntax to allow for a simplified transition for engineers in this field (this is discussed further in a later section).

\paragraph{State of coverage in Chisel} Up until recently, the main Chisel developers have mostly focused their energy on getting chisel up to the standards imposed by main stream HDLs like VHDL or Verilog. This means that verification features are mostly lacking from the Chisel package. Some testing frameworks like \textit{ChiselTest}~\cite{chisel:tester2} have come to be, but they still lack coverage capabilities. All of this amounts to the realisation that if one wants to gather code coverage of a current Chisel design, we need to rely on basic Scala software code coverage tools (which we explore in more detail in a later section). This is why we have decided to focus our energy on this and to introduce code coverage solutions that are specifically tailored for Chisel and we will discuss this in great detail in the following sections.

\section{Statement Coverage at the Verilog level}
\todo{This is just a draft}
Since chisel is not a synt language it relies on traforming the IR of firrtl to Verilog.
The verilog code can then be simulate by any Verilog simulator. In the Chisel echosystem,
the generated verilog code can be simulate with ChiselTest using the Verilator backend.

Verilator is an open source simulator part of the chipaliance. Supported by a numerous group of company,
verilator ranks as one of the vastest Verilog simulator available today outperforming commercial simulators. It translate
verilog code to C++/SystemC code that can be compiled in native code and thus run by any modern computer.

Since version 3.6*, Verilator started introducing coverage support. The current version of Verilator supports three types
of coverage, line coverage, toggle coverage and SystemVerilog Assertion property coverage. The desing coverage can be enabled
during the translation from verilog to C++ code by invoking the veriltor binary with the --coverage-line, --coverage-togle, --coverage-user parameters respectivelly.
If the user wants to enable all the three options the --coverage parameter can be used instead.

The coverage line parameter is used to specify coverage analysis for each code flow change point in the Verilog source code. For each of these decision points, a counter is incremented every time the specific branch is selected. The toggle coverage line parameter enables the analysis of every signal in a module. With this parameter enabled, every signal that is not local to the module has a counter that increments every time the signal is toggled. Lastly, the user coverage toggle enables user-defined functional coverage in the form of SystemVerilog assertions. This type of coverage is not considered in this report since it requires custom transformation for inserting SystemVerilog assertion in the generate Verilog code through FIRRTL annotation. 

When the simulation is run with coverage enabled, at the end of the simulation Verilator generates a coverage report in form of a dat file. The dat file per se doesn't provide any usefull infromation to the user because it is cryptic but it can read by differen coverage tools and report the ammount of code cover. 

One of the most used front end for code coverage is lcov. Lcov is a graphical front end developed as part of the linux test project and it is able to read coverage results and display them into a graphical report in form of an HTML page through its companion utility genhtml. As part of Google Summer Of Code 2014, Rick Brow rewrote the genhtml utility to Java.

ChiselTest laverage the ScalaTest echosystem to test the models of Chisel. ScalaTest is able to generate report at the end of each test. By creating a custom report generator it was possible to generate a complete coverage report at the end of each test wich can combine the coverage of multiple test specified inside a test suite.

The last release of chiseltest 0.2.3 allows the user to conditionally use the verilator backend with coverage functionality enabled by specify a sequence of annotations
for a specific test.

\section{Statement Coverage at the FIRRTL level}  
Let us now move up an abstraction level and discuss how we've gone about implementing statement coverage at the FIRRTL level. First of all, we must briefly discuss the utility of having coverage at an intermediate representation level. FIRRTL is a direct translation of the input Chisel source, meaning that it can be mapped intuitively back up to the designer's code. An argument for the useful of coverage information at such an abstraction level is the fact that in FIRRTL, all hardware generators are expanded, meaning that what we see is information on the generated hardware rather than the hardware generating code. 

Our solution was implemented in Treadle, a common FIRRTL execution engine used to simulate designs implemented in Chisel. This engine runs on the FIRRTL intermediate representation code generated by a given Chisel implementation and allows one to run user-defined tests on the design using frameworks like \textit{iotesters} or the more recent \textit{ChiselTest}. One way to obtain FIRRTL-level statement coverage would to run our tests through an extended version of Treadle (available through a SNAPSHOT at the time of writing) capable of keeping track of the necessary information.

The solution that was used to implement statement coverage was based off of a method presented by Ira. D. Baxter~\cite{branch-cov-made-easy:2002}. The idea is to add additional outputs for each multiplexer in the design. These new ports, which we will call \textit{Coverage Validators}, are set depending on the paths taken by each multiplexer. That information is then gathered at the end of each test and maintained throughout a test suite. Once the testing process is done, we use the output values gathered from the \textit{Coverage Validators} to check whether or not a certain multiplexer path was taken during the test, all of this resulting in a branch coverage percentage. This percentage can then be simply mapped to a statement coverage amount.

This was implemented in Treadle by creating a custom pass of the FIRRTL compiler that traverses the sources Abstract Syntax Tree (\textit{AST}) and adds the wanted outputs and coverage expressions into the said data structure. Once that is done, the \texttt{TreadleTester} samples those additional outputs every time the \texttt{expect} method is called and keeps track of their values throughout a test suite. Finally it generates a Scala \texttt{case class} containing the following coverage information:
\begin{itemize}
\item The multiplexer path coverage percentage.
\item The coverage Validator lines that were covered by a test.
\item The modified LoFIRRTL source code in the form of a \texttt{List[String]}.
\end{itemize}
The \texttt{CoverageReport} case class can then be serialized, giving the following report:
\begin{verbatim}
COVERAGE: 50.0% of multiplexer paths tested
COVERAGE REPORT:

+ circuit Test_1 :
+   module Test_1 :
+     input io_a : UInt<1>
+     input io_b_0 : UInt<2>
+     input io_b_1 : UInt<2>
+     input clock : Clock
+     output io_cov_valid_0 : UInt<1>
+     output io_cov_valid_1 : UInt<1>
+     output out : UInt<2>
+   
+     io_cov_valid_0 <= io_a
-     io_cov_valid_1 <= not(io_a)
+     out <= mux(io_a, io_b_0, io_b_1)
\end{verbatim}
The example above is taken from a simple test, where we are only testing the path where \texttt{in\_a} is 1. This means that, since we only have a single multiplexer, only half of our branches have been tested and we would thus want to add a test for the case where \texttt{in\_a} is 0. The report can thus be interpreted as follows:  
\begin{itemize}
\item "\texttt{+}" before a line, means that it was executed in at least one of the tests in the test suite.
\item "\texttt{-}" before a line, means that it wasn't executed in any of the tests in the test suite.
\end{itemize}

Treadle thus allows us to obtain coverage at the FIRRTL level. An interesting result can be obtained by mapping the FIRRTL statement coverage to the original Chisel source. This is possible by accessing the original source code through \textit{Source locators} which map some of the FIRRTL lines back to Chisel. An other way to obtain coverage information directly on our original source code would be to use software test coverage techniques, which we wil explore in detail in the upcoming section.

\section{Statement Coverage at the Scala level}
\todo{Hans' work goes here}

\section{Functional Coverage directly in Scala}
\todo{Adapt this section to fit into a discussion on coverage rather than a presentation of a framework.}
Functional Coverage is one of the principal tools used during the verification process, since it allows one to have a measurement of \textit{"how much of the specification has been implemented correctly"}. A verification framework would thus not be complete without constructs allowing one to define a verification plan and retrieve a functional coverage report. The main language used for functional coverage is \textit{SystemVerilog}, which is why our solution is based on the same syntax. There are three main components to defining a verification plan: 
\begin{itemize}
\item \texttt{Bin}: Defines a range of values that should be tested for (i.e. what values can we expect to get from a given port).
\item \texttt{CoverPoint}: Defines a port that needs to be sampled in the coverage report. These are defined using a set of bins.
\item \texttt{CoverGroup}: Defines a set of \texttt{CoverPoint}s that need to be sampled at the same time.
\end{itemize}
Using the above elements, one can define what's known as a verification plan, which tells the coverage reporter what ports need to be sampled in order to generate a report.
In order to implement said elements in Scala we needed to be able to do the following:
\begin{itemize}
\item Define a verification plan (using constructs similar to \texttt{coverpoint} and \texttt{bins}).
\item Sample DUT ports (for example by hooking into the \textit{Chisel Testers2} framework).
\item Keep track of bins to sampled value matches (using a sort of DataBase).
\item Compile all of the results into a comprehensible Coverage Report.
\end{itemize}
Implementing these elements was done using a structure where we had a top-level element, known as our \texttt{Coverage Reporter} which allows the verification engineer to define a verification plan using the \texttt{register} method, which itself stores the \texttt{coverpoint} to \texttt{bin} mappings inside of our \texttt{CoverageDB}. Once the verification plan is defined, we can sample our ports using the \texttt{sample} method, which is done by hooking into \textit{Chisel Testers2} in order to use its peeking capabilities. At the end of the test suite a functional coverage report can be generated using the \texttt{printReport} method, which shows us how many of the possible values, defined by our bin ranges, were obtained during the simulation.
\begin{lstlisting}[language=scala]
val cr = new CoverageReporter
cr.register(
    //Declare CoverPoints
    //CoverPoint 1
    CoverPoint(dut.io.accu , "accu",
        Bins("lo10", 0 to 10)::
        Bins("First100", 0 to 100)
        ::Nil)::
    //CoverPoint 2
    CoverPoint(dut.io.test, "test", 
        Bins("testLo10", 0 to 10)
        ::Nil)::
    Nil,
    //Declare cross points
    Cross("accuAndTest", "accu", "test",
        CrossBin("both1", 1 to 1, 1 to 1)
        ::Nil)::
    Nil)
\end{lstlisting}
The above code snippet is an example of how to define a verification plan using our coverage framework. The concepts are directly taken from \texttt{SystemVerilog}, so it should be accessible to anyone coming from there. One concept, that is used in the example verification plan, which we haven't presented yet is the idea of \textit{Cross Coverage} defined using the \texttt{Cross} construct. \textit{Cross Coverage} allows one to specify coverage relations between CoverPoints. This means that a cross defined between, let's say, \texttt{coverpoint a} and \texttt{coverpoint b} will be used to gather information about when \texttt{a} and \texttt{b} had certain values simultaneously. Thus in example verification plan we are checking that \texttt{accu} and \texttt{test} take the value 1 at the same time.

Once our verification plan is defined, we need to decide when we want to sample our cover points. This means that at some point in our test, we have to tell our \texttt{CoverageReporter} to sample the values of all of the points defined in our verification plan. This can be done, in our example, simply by calling \texttt{cr.sample()} when we are ready to sample our points. Finally once our tests are done, we can ask for a coverage report by calling \texttt{cr.printReport()} which results in the following coverage report: 
\begin{verbatim}
============== COVERAGE REPORT ==============
================ GROUP ID: 1 ================
COVER_POINT PORT NAME: accu
BIN lo10 COVERING Range 0 to 10 HAS 8 HIT(S)
BIN First100 COVERING Range 0 to 100 HAS 9 HIT(S)
============================================
COVER_POINT PORT NAME: test
BIN testLo10 COVERING Range 0 to 10 HAS 8 HIT(S)
============================================
CROSS_POINT accuAndTest FOR POINTS accu AND test
BIN both1 COVERING Range 1 to 1 CROSS Range 1 to 1 
HAS 1 HIT(S)
============================================
\end{verbatim}
An other option would be, for example if we want to do automated constraint modifications depending on the current coverage, to generate the coverage as a Scala \texttt{case class} and then to use it's \texttt{binNcases} method to get numerical and reusable coverage results.  
  
One final element that our framework offers is the possibility to gater delayed coverage relationships between two coverage points. The idea is similar to how a \texttt{Cross} works, but this time rather than sampling both points in the same cycle, we rather look at the relation between one point at the starting cycle and an other point sampled a given number of cycles later. This number of cycles is called the \texttt{delay} and there are currently three different ways to specify it:  
\begin{itemize}
 \item \texttt{Exactly} delay, means that a hit will only be considered if the second point is sampled in its range a given number of cycles after the first point was.
 \item \texttt{Eventually} delay, means that a hit will be considered if the second point is sampled in its range at any point within the following given number of cycles after the first point was.  
 \item \texttt{Always} delay, means that a hit will be considered if the second point is sampled in its range during every cycle for a given number of cycles after the first point was sampled.
\end{itemize}

\section{Efficiency Evaluation}
\todo{Maybe add a bit on Tjark's use case?}

\section{Related work}
Our current coverage discussion proposes third party libraries  as solutions for gathering statement and functional coverage at multiple levels of abstraction. However, as we presented earlier, SystemVerilog, a mostly non-synthesisable extension of the Verilog HDL, contains certain constructs capable of gathering coverage information~\cite{spear2008systemverilog}. Developers of the Chisel language have thus been currently working on trying to make these constructs available directly in Chisel, which would allow them to be embedded in the language. This resulted in a \texttt{cover} statement being introduced in an experimental verification library as part of the Chisel 3.4.0 release~\cite{chisel3.4release_notes}. This \texttt{cover} statement was then given an equivalent at the FIRRTL level, which then maps down to SystemVerilog rather than plain Verilog. There is yet to be mainstream support for this new construct by FIRRTL execution engines like Treadle, which would explain why it remains experimental. Our solution greatly differs from this approach, since we try to utilise pre-existing language features from Chisel/Scala in order to enable coverage in the simplest possible manner. 

We defend the idea of reimplementing features from SystemVerilog in Scala (in Open-Source), rather than relying on the language itself, since it improves the overall cohesion of the Chisel-Scala ecosystem and removes the need to learn a language that has 250 key-words, thus saving the verification engineers time and improving overall efficiency of the verification process (which remains our main goal). Following that same idea, we will briefly mention the work conducted in parallel to the research presented in this paper, namely ChiselVerify~\cite{chiselverify}, our work on constructing a verification library, in Scala, that brings many features from SystemVerilog over to Chisel. The goal of the project is to allow for UVM style testing to be done on Chisel designs without having to rely SystemVerilog. 
\section{Conclusion}
We propose multiple solutions for the gathering of coverage data in high-level chisel designs. Previously, one needed to rely on other languages such as SystemVerilog in order obtain coverage information during the verification of a Chisel design. This meant that testing either fully needed to be done in an other language or we needed to turn to multi-language testing which was very often cumbersome and time-consuming. With our solutions we are bringing the world one step closer to making Chisel a fully capable design and verification language. We now no longer need to rely on other languages in order to gather statement and functional coverage of our Chisel designs. An interesting discussion to be had is around the abstraction-level that should be used to gather coverage. One could justify that high-level coverage information lacks usefulness when using hardware generators since we would rather have information on the execution of the generated hardware rather than the generator itself, but of course this discussion is left up for the reader to have. We also proposed a solution for functional coverage entirely in Scala, this is actually a small part of a much broader research project name ChiselVerify, done on bringing most aspects of design verification to the Chisel ecosystem.

\section{Acknowledgements}
We would like to thank the researchers at Berkeley who are constantly working on making Chisel a more ubiquitous hardware construction language and for the feedback related to our work on adding coverage to Treadle. We would also like to thank the members of the embedded systems section at DTU for providing a constantly stimulating environment and InfinIT for funding the project.

\bibliographystyle{abbrv}
\bibliography{coverage}


\end{document}
