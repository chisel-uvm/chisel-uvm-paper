\documentclass[conference]{IEEEtran}

\usepackage{cite}
\usepackage{pslatex} % -- times instead of computer modern, especially for the plain article class
\usepackage[colorlinks=false,bookmarks=false]{hyperref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{comment}
\usepackage{listings}

\usepackage{xspace}		% For using \SV with trailing spaces
\usepackage{cleveref}	% Needed for correctly referencing listings

\newcommand{\code}[1]{{\small{\texttt{#1}}}}
\newcommand{\SV}{SystemVerilog\xspace}


% fatter TT font
\renewcommand*\ttdefault{txtt}
\newcommand{\todo}[1]{{\color{olive} TODO: #1}}
\newcommand{\martin}[1]{{\color{blue} Martin: #1}}
\newcommand{\simon}[1]{{\color{green} Simon: #1}}
\newcommand{\abcdef}[1]{{\color{red} Author2: #1}}
\newcommand{\rewrite}[1]{{\color{red} rewrite: #1}}
\newcommand{\ducky}[1]{{\color{orange} Richard: #1}}
\newcommand{\kasper}[1]{{\color{purple} Kasper: #1}}

% uncomment following for final submission
%\renewcommand{\todo}[1]{}
%\renewcommand{\martin}[1]{}
%\renewcommand{\simon}[1]{}
%\renewcommand{\kasper}[1]{}
%\renewcommand{\ducky}[1]{}


%%% ZF
\usepackage{listings}
\lstset{
	columns=fullflexible,
	%        basicstyle=\ttfamily\footnotesize,
	basicstyle=\ttfamily\small,      
	%columns=fullflexible, keepspaces=true,
	numbers=left,    
	numberblanklines=false,
	captionpos=b,
	%	breaklines=true,
	escapeinside={@}{@},
	numbersep=5pt,
	language=C,
	tabsize=2,
	breakatwhitespace=true,
	breaklines=true,
	deletekeywords={for},
	%        keywordstyle=\ttfamily
	numbersep=5pt,
	xleftmargin=.10in,
	%xrightmargin=.25in
}

\newcommand{\longlist}[3]{{\lstinputlisting[float, caption={#2}, label={#3}, frame=tb, captionpos=b]{#1}}}

\bibliography{./coverage}

\title{Improving the Verification Efficiency of Chisel Designs with Multi-Level Code Coverage}

\author{\IEEEauthorblockN{Andrew Dobis, Enrico Tolotto, Hans Jakob Damsgaard, Tjark Petersen, Martin Schoeberl}\\
\IEEEauthorblockA{\textit{Department of Applied Mathematics and Computer Science} \\
\textit{Technical University of Denmark}\\
Lyngby, Denmark \\\\
andrew.dobis@alumni.epfl.ch, s190057@student.dtu.dk, s163915@student.dtu.dk, masca@dtu.dk}
}


\begin{document}

\maketitle \thispagestyle{empty}


\begin{abstract}
Ever-increasing performance demands are pushing hardware designers towards the use of domain-specific accelerators. This means that more and more hardware must be designed from scratch in an ever shortening amount of time. We must thus find a way to improve the overall efficiency of the hardware design and verification cycles. The design efficiency was improved with the introduction of Chisel, however we still need to improve the verification efficiency. That is why we propose, in this paper, multiple solutions for adding one of the most important verification tools there is: code coverage. 

We explored and created methods to be able to obtain Statement coverage of a Chisel design at multiple levels of abstraction: at the Verilog, FIRRTL and Scala levels. The Verilog statement coverage is obtained by hooking into verilator and extracting the coverage results. The FIRRTL statement coverage is done by modifying the Treadle execution engine and running a custom FIRRTL compiler pass that adds coverage-gathering outputs to the generated AST in order to obtain information about the executed paths. Finally the Scala coverage is obtained using software coverage gathering tools found in the ScalaTest library. After exploring the potential statement coverage solutions, we move on to presenting our own Scala-implemented solution for gathering functional coverage on a Chisel design.  

We then finish off by presenting an industry-provided use case that illustrates the efficiency of our coverage tools. These solutions give the verification engineer ample ways to gather coverage on a Chisel design at any abstraction level. Note that a discussion could be had on the usefulness of coverage information at certain levels of abstraction (i.e. high-level coverage might not be interesting when using hardware generators), but for now this is left up for the reader to decide.
\end{abstract}

\begin{IEEEkeywords}
hardware verification, code coverage, SystemVerilog, Chisel, Scala, FIRRTL
\end{IEEEkeywords}


\section{Introduction and Objectives}
\label{sec:objectives}
As time passes, contemporary hardware design is met with tighter and tighter time constraints. This is added to the fact that, with the halting of Moore's law, hardware designers are turning to domain-specific accelerators in order to keep up with the ever-increasing performance demands~\cite{henn-patt:turing:2019}. This means that more and more hardware must be designed from scratch in shorter and shorter time periods~\cite{domain-hw-acc:2020}. However, the most widely used hardware description languages (i.e. VHDL and Verilog) are completely outdated and inefficient. To solve said problem, researchers at the University of California in Berkeley proposed Chisel~\cite{chisel:dac2012}, a Scala embedded high-level hardware construction language.

This solution is great, but is still lacking in verification functionalities and one of the main tools needed for the verification of digital systems is Code Coverage. This allows verification engineers to measure their progress throughout the testing process and have an idea of how effective their tests actually are. Coverage can be separated into multiple distinct categories, but we will focus on the following two: Statement and Functional coverage. Statement Coverage defines a quantitative measure of the testing progress, \textit{"How many lines of code have been tested?"}, whereas Functional Coverage gives a rather qualitative measure, \textit{"How many functionalities have we tested?"}~\cite{spear2008systemverilog}.

In this paper we will propose three different methods for obtaining statement coverage, each at different levels of abstraction. We will present these methods in a bottom-up fashion: first off we will talk about obtaining statement coverage of the Verilog description generated by Chisel, secondly we will show our solution for getting statement coverage of the FIRRTL intermediate representation and finally we will talk about getting coverage directly at the Scala level. Once that is done we will also present our solution for gathering functional code coverage of the Chisel design directly in Scala. In the following section we will take a brief look at the Chisel hardware construction language, how FIRRTL comes into play and gather the knowledge needed to fully appreciate our solutions.

\section{Background and State-of-the-Art}
\label{sec:background}
We will begin our brief overview by presenting Chisel and all of the tools surrounding it.
\paragraph{Chisel} Chisel is a hardware construction language embedded in the functional and Object-Oriented Programming (OOP) language Scala~\cite{scala:2006}. This means that a Chisel design actually generates a Verilog description that can then be synthesised. The language itself has syntax rooted in Scala, since Chisel is technically Scala code. This thus allows the description of hardware in a high-level manner, which is thus much for efficient than traditional HDLs like VHDL or Verilog. Scala also allows for both functional and OOP constructs, which makes it possible to organise a design implementation very intuitively using Scala classes and objects and also to use the power of higher order functions to greatly simplify descriptions thanks to constructs like \textit{mapping} or \textit{reductions}.
\paragraph{FIRRTL} In modern a Chisel design, the source code is first compiled into an intermediate representation that is used as a sort of "optimisation layer" before being converted into the final Verilog form. During this optimisation process the origin Chisel description goes through three different intermediate representation layers:
\begin{itemize}
\item High-FIRRTL, which is a form that maps perfectly back to chisel, but with the firrtl structure.
\item Mid-FIRRTL, which is a form where abstract constructs are simplified, i.e. loops are unrolled and arrays are flattened.
\item Low-FIRRTL, which maps perfectly to RTL code with high-level conditional statements turned into multiplexers.
\end{itemize}
Throughout this optimisation process, custom FIRRTL compiler passes, known as \textit{Transforms} can be used to modify the design. This is often done when trying to apply simplifications to the design to make the generated hardware more optimal~\cite{firrtlTechRep2016}.
\paragraph{Code Coverage} In software development, code coverage is used as a metric to measure the completeness of a testing suite. In recent years, these techniques, originally used for software, have been brought into the hardware verification universe in an attempt to reduce post-printing errors. The coverage metric can be defined in multiple ways, but in this paper we will mostly focus on two key aspects of it: Statement Coverage and Functional Coverage.

\textbf{Statement Coverage.} When wanting to retrieve coverage information about a specific program or design implementation, statement coverage will give us a quantitative measure of our testing progress. It measures which percentage of individual statements in our code have been tested. This metric can be very useful in the software world, when it comes to completeness of a testing suite, however it is only a partial solution in the hardware world, since it only tells us which lines were tested and not how well they were tested.  

\textbf{Functional Coverage.} If we are looking to measure the completeness of a test suite, we can not forget to ask the following question: "are we even testing the right thing?". In the hardware world, engineers usually implement designs based off of pre-determined specifications, so when testing, we should also have a metric for how well we are implementing the specification. This is where Functional Coverage comes in. The idea is to first define what is called a \textit{Verification Plan}~\cite{spear2008systemverilog}, which is supposed to represent the specification we are trying to implement. Once that is done, we can then sample the different points defined in our specification during the testing process, to obtain results in the form of: \textit{"test suite T covered a total of x\% of the values specified by point P in specification A"}. This was first implemented in SystemVerilog, in which a verification plan was defined using the following constructs:  
\begin{itemize}
\item \texttt{Bin}: Defines a range of values that should be tested for (i.e. what values can we expect to get from a given port).
\item \texttt{CoverPoint}: Defines a port that needs to be sampled in the coverage report. These are defined using a set of bins.
\item \texttt{CoverGroup}: Defines a set of \texttt{CoverPoint}s that need to be sampled at the same time.
\end{itemize}
Our solution tries to mimic this verification plan syntax to allow for a simplified transition for engineers in this field (this is discussed further in a later section).

\paragraph{State of coverage in Chisel} Up until recently, the main Chisel developers have mostly focused their energy on getting chisel up to the standards imposed by main stream HDLs like VHDL or Verilog. This means that verification features are mostly lacking from the Chisel package. Some testing frameworks like \textit{ChiselTest}~\cite{chisel:tester2} have come to be, but they still lack coverage capabilities. All of this amounts to the realisation that if one wants to gather code coverage of a current Chisel design, we need to rely on basic Scala software code coverage tools (which we explore in more detail in a later section). This is why we have decided to focus our energy on this and to introduce code coverage solutions that are specifically tailored for Chisel and we will discuss this in great detail in the following sections.

\section{Statement Coverage at the Verilog level}
Since Chisel as a language is not supported by any synthesis tools, it relies on transforming the intermediate representation of the FIRRTL stage into Verilog.  The Verilog code generated can then be simulated by any Verilog simulator or directly synthesized by any vendor-specific development tools. As part of the Chisel development tools, ChiselTest is a library based on ScalaTest \cite{ScalaTest}, which allows simulating Chisel design transformed to Verilog using the Verilator \cite{verilator} backend.

Verilator is an open-source simulator guided by the Chips Alliance and Linux Foundation project. Verilator ranks as one of the fastest Verilog simulators available today, outperforming commercial simulators, and it is supported and used by numerous companies dominating the industries. It allows translating Verilog code to C++/SystemC code that can be compiled natively and run by any modern computer.

Since version 2.1, Verilator started introducing coverage and functional coverage support. The current version of Verilator (4.108) supports three types of coverage: line coverage, toggle coverage, and SystemVerilog Assertion property coverage. The recording of the coverage can be enabled during the translation from Verilog to C++ code by invoking the Veriltor binary with the \textit{--coverage-line}, \textit{--coverage-toggle}, \textit{--coverage-user} parameters, respectively. A fourth parameter called \textit{--coverage} is available to the users, and it enables all three types of coverage simultaneously.

The coverage line parameter is used to specify coverage analysis for each code flow change point in the Verilog source code \cite{verilatormanual}. For each of these decision points, a counter is kept and incremented every time the specific path is taken during the simulation. The toggle coverage line parameter enables the analysis of every signal in a module. With this parameter enabled, every signal that is not local to the module has a counter that increments every time the signal changes states. Lastly, the user coverage toggle enables user-defined functional coverage in the form of SystemVerilog assertions. This type of coverage is not considered in this report since it requires manual intervention from the user or implementing a custom transformation for inserting SystemVerilog assertion in the generate Verilog code through FIRRTL annotation.

When the simulation is run with coverage enabled, Verilator generates a coverage report in a SystemPerl \cite{SystemPerl} coverage report file for each different test at the end of the simulation. The output of multiple tests can then be combined by using the \textit{verilator\_coverage} utility provided with Verilator. The merged report file can then be transformed into an info file and processed by any coverage tools or extensions.

One of the most used front end for code coverage is LCOV \cite{Lcov}. LCOV is a graphical front end developed as part of the Linux test project, and it can read coverage results and display them in the form of an HTML page through its companion utility genhtml. As part of Google Summer Of Code 2014, genhtml was ported into Java by Rick Brown under the name jgenhtml \cite{jgenhtml}.

By combining genhtml, Verilator, and ChiseTest, it is possible to automatically generate a coverage report for each test suite specified inside ChiselTest. As a part of the research project, we extended the ChiselTester library with a custom ScalTest reporter generator that automatically detects the coverage files generated by Verilator, merges them, and creates an HTML page reporting the source code of the module tested and displaying which lines were covered during the run of the test suite.

Every time the user creates a test suite that mixes a new Scala trait called  CoverageTrait in the ScalaTest suite, a similar output will appear at the end of the test:
\begin{lstlisting}[language=bash]
Reading data file: output.info
Found common filename prefix /Users/enrico/Documents/Git/transfer/output/uvm/
Generating output at [...]/transfer/output/uvm/chisel.AluAccuTester
Writing report for AluAccuChisel.v
Writing directory view page.
Overall coverage rate:
	lines......: 100.0% (13 of 13 lines)
	functions: no data found
	branches: no data found
Line coverage 100.0%, Coverage saved in file:///[...]/transfer/output/uvm/chisel.AluAccuTester/VerilatorCoverage.html
[info] ScalaTest
[info] Run completed in 6 seconds, 258 milliseconds.
[info] Total number of tests run: 7
[info] Suites: completed 5, aborted 0
[info] Tests: succeeded 7, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[info] Passed: Total 7, Failed 0, Errors 0, Passed 7
[success] Total time: 12 s, completed Dec 10, 2020 9:24:46 PM
\end{lstlisting}

And consequently the HTML output is:

\begin{figure}[htb]
\centering
\includegraphics[width=\linewidth]{htmlreport.png}
\caption{Custom HTML ChiseTest report with Verilator coverage}
\label{fig:customhtmlreport}
\end{figure}

\section{Statement Coverage at the FIRRTL level}  
Let us now move up an abstraction level and discuss how we've gone about implementing statement coverage at the FIRRTL level. First of all, we must briefly discuss the utility of having coverage at an intermediate representation level. FIRRTL is a direct translation of the input Chisel source, meaning that it can be mapped intuitively back up to the designer's code. An argument for the useful of coverage information at such an abstraction level is the fact that in FIRRTL, all hardware generators are expanded, meaning that what we see is information on the generated hardware rather than the hardware generating code. 

Our solution was implemented in Treadle, a common FIRRTL execution engine used to simulate designs implemented in Chisel. This engine runs on the FIRRTL intermediate representation code generated by a given Chisel implementation and allows one to run user-defined tests on the design using frameworks like \textit{iotesters} or the more recent \textit{ChiselTest}. One way to obtain FIRRTL-level statement coverage would to run our tests through an extended version of Treadle (available through a SNAPSHOT at the time of writing) capable of keeping track of the necessary information.

The solution that was used to implement statement coverage was based off of a method presented by Ira. D. Baxter~\cite{branch-cov-made-easy:2002}. The idea is to add additional outputs for each multiplexer in the design. These new ports, which we will call \textit{Coverage Validators}, are set depending on the paths taken by each multiplexer. That information is then gathered at the end of each test and maintained throughout a test suite. Once the testing process is done, we use the output values gathered from the \textit{Coverage Validators} to check whether or not a certain multiplexer path was taken during the test, all of this resulting in a branch coverage percentage. This percentage can then be simply mapped to a statement coverage amount.

This was implemented in Treadle by creating a custom pass of the FIRRTL compiler that traverses the sources Abstract Syntax Tree (\textit{AST}) and adds the wanted outputs and coverage expressions into the said data structure. Once that is done, the \texttt{TreadleTester} samples those additional outputs every time the \texttt{expect} method is called and keeps track of their values throughout a test suite. Finally it generates a Scala \texttt{case class} containing the following coverage information:
\begin{itemize}
\item The multiplexer path coverage percentage.
\item The coverage Validator lines that were covered by a test.
\item The modified LoFIRRTL source code in the form of a \texttt{List[String]}.
\end{itemize}
The \texttt{CoverageReport} case class can then be serialized, giving the following report:
\begin{verbatim}
COVERAGE: 50.0% of multiplexer paths tested
COVERAGE REPORT:

+ circuit Test_1 :
+   module Test_1 :
+     input io_a : UInt<1>
+     input io_b_0 : UInt<2>
+     input io_b_1 : UInt<2>
+     input clock : Clock
+     output io_cov_valid_0 : UInt<1>
+     output io_cov_valid_1 : UInt<1>
+     output out : UInt<2>
+   
+     io_cov_valid_0 <= io_a
-     io_cov_valid_1 <= not(io_a)
+     out <= mux(io_a, io_b_0, io_b_1)
\end{verbatim}
The example above is taken from a simple test, where we are only testing the path where \texttt{in\_a} is 1. This means that, since we only have a single multiplexer, only half of our branches have been tested and we would thus want to add a test for the case where \texttt{in\_a} is 0. The report can thus be interpreted as follows:  
\begin{itemize}
\item "\texttt{+}" before a line, means that it was executed in at least one of the tests in the test suite.
\item "\texttt{-}" before a line, means that it wasn't executed in any of the tests in the test suite.
\end{itemize}

Treadle thus allows us to obtain coverage at the FIRRTL level. An interesting result can be obtained by mapping the FIRRTL statement coverage to the original Chisel source. This is possible by accessing the original source code through \textit{Source locators} which map some of the FIRRTL lines back to Chisel. An other way to obtain coverage information directly on our original source code would be to use software test coverage techniques, which we wil explore in detail in the upcoming section.

\section{Statement Coverage at the Scala level}
Scala and Scalatest has some coverage functionality for software testing built-in -- specifically, we have looked at the Scoverage plugin which is available with ScalaC through SBT and Maven \cite{scoverage}. Scoverage supports statement and branch coverage rather than simple line coverage that is typical for coverage tools used with less expressive languages such as C. We note that according to the Chisel3 GitHub wiki-page, Scoverage should work with Chisel \cite{chisel:scoverage}.

\subsection{Using the Scoverage Plugin}
To enable coverage, the Scoverage plugin must be added to the Scala project's \textit{plugins.sbt} file, and a number of optional arguments may be included in the project's \textit{build.sbt} file -- the arguments specify whether coverage is enabled, a targeted coverage percentage etc. An example configuration is provided below:
\begin{verbatim}
coverageEnabled := true
coverageMinimum := 70
coverageFailOnMinimum := false
coverageHighlighting := true
\end{verbatim}
Running a test is still just a matter of running e.g. \texttt{sbt test}, while generating a coverage report requires running \texttt{sbt coverageReport} afterwards as Scoverage otherwise simply generates coverage databases. The result is a set of HTML files which may be opened in one's browser. If the \texttt{coverageHighlighting} option is enabled, the page includes the original source files with statements that were executed during the test marked in green. The global coverage results are also printed in the terminal:
\begin{verbatim}
[info] Statement coverage.: 100.00%
[info] Branch coverage....: 100.00%
\end{verbatim}

\subsection{Scoverage Limitations}
Experimenting with Scoverage in combination with Chisel revealed some limitations. In particular, some of the basic constructs introduced by Chisel, e.g., \texttt{switch} statements, are simply not considered by the Coverage tool and thus, incorrect results are reported. In practice, this makes Scoverage insufficient for most, even basic, designs.

\section{Functional Coverage directly in Scala}
Functional Coverage is one of the principal tools used during the verification process. It allows one to measure \textit{"how much of the specification has been implemented correctly"}. A discussion on hardware verification would thus not be complete without constructs allowing one to define a verification plan and retrieve a functional coverage report. The main language used for functional coverage is usually \textit{SystemVerilog}, which is why our solution is based on the same syntax. 

As a quick refresher, Fucntional Coverage is based on three base elements: \texttt{Bins}, \texttt{CoverPoints} and \texttt{CoverGroups}. Using these, one can define what's known as a verification plan, which tells the coverage reporter what ports need to be sampled and taken into account in the coverage report.
In order to implement said elements in Scala we needed to be able to do the following:
\begin{itemize}
\item Define a verification plan (using constructs similar to \texttt{coverpoint} and \texttt{bins}).
\item Sample DUT ports (for example by hooking into the \textit{ChiselTest} framework).
\item Keep track of the number of hits that a bin has obtained (using a sort of DataBase).
\item Compile all of the results into a comprehensible Coverage Report.
\end{itemize}
Implementing this was done using a structure similar to the one used in SystemVerilog~\cite{spear2008systemverilog}. We start with a top-level construct, known as a \texttt{Coverage Reporter}, which allows one to define a verification plan using the \texttt{register} method, which itself stores the \texttt{coverpoint} to \texttt{bin} mappings inside of a \texttt{CoverageDB}. Once the verification plan is defined, we can sample the DUT ports using the \texttt{sample} method, which hooks into \textit{ChiselTest} in order to use its peeking capabilities. At the end of the test suite a functional coverage report can be generated using the \texttt{printReport} method, which shows us how many of the possible values, defined by our bin ranges, were obtained during the simulation.
\begin{lstlisting}[language=scala]
val cr = new CoverageReporter
cr.register(
    //Declare CoverPoints
    //CoverPoint 1
    CoverPoint(dut.io.accu , "accu",
        Bins("lo10", 0 to 10)::
        Bins("First100", 0 to 100)
        ::Nil)::
    //CoverPoint 2
    CoverPoint(dut.io.test, "test", 
        Bins("testLo10", 0 to 10)
        ::Nil)::
    Nil,
    //Declare cross points
    Cross("accuAndTest", "accu", "test",
        CrossBin("both1", 1 to 1, 1 to 1)
        ::Nil)::
    Nil)
\end{lstlisting}
The above code snippet is an example of how to define a verification plan using our Scala solution. The concepts are directly taken from \texttt{SystemVerilog}, so it should be accessible to anyone coming from that environment. 

\subsection{Cross Coverage}
An other concept, which we haven't presented yet, that is used in the example verification plan, is the idea of \textit{Cross Coverage} defined using the \texttt{Cross} construct. \textit{Cross Coverage} allows us to specify coverage relations between CoverPoints. This means that a cross defined between, let's say, \texttt{coverpoint a} and \texttt{coverpoint b} will be used to gather information about when \texttt{a} and \texttt{b} had certain values simultaneously. In the example verification plan, we thus are verifying that \texttt{accu} and \texttt{test} take the value 1 at the same time.

\subsection{Generating the Coverage Report}
After defining a verification plan, we need to decide when we want to sample our cover points. This means that at some point in our test, we have to tell our \texttt{CoverageReporter} to sample the values of all of the points defined in our verification plan. This can be done, in our example, simply by calling \texttt{cr.sample()} when we are ready to sample our points. Finally once our tests are done, we can ask for a coverage report by calling \texttt{cr.printReport()} which results in the following coverage report: 
\begin{verbatim}
============== COVERAGE REPORT ==============
================ GROUP ID: 1 ================
COVER_POINT PORT NAME: accu
BIN lo10 COVERING Range 0 to 10 HAS 8 HIT(S)
BIN First100 COVERING Range 0 to 100 HAS 9 HIT(S)
============================================
COVER_POINT PORT NAME: test
BIN testLo10 COVERING Range 0 to 10 HAS 8 HIT(S)
============================================
CROSS_POINT accuAndTest FOR POINTS accu AND test
BIN both1 COVERING Range 1 to 1 CROSS Range 1 to 1 
HAS 1 HIT(S)
============================================
\end{verbatim}
An other option would be, for example if we want to do automated constraint modifications depending on the current coverage, to generate the coverage as a Scala \texttt{case class} and then to use it's \texttt{binNcases} method to get numerical and reusable coverage results.  
  
\subsection{Timed Coverage}
One final element that our framework offers is the possibility to gather delayed coverage relationships between two coverage points. The idea is similar to how a \texttt{Cross} works, but this time rather than sampling both points in the same cycle, we rather look at the relation between one point at the starting cycle and an other point sampled a given number of cycles later. This number of cycles is called the \texttt{delay} and there are currently three different ways to specify it:  
\begin{itemize}
 \item \texttt{Exactly} delay, means that a hit will only be considered if the second point is sampled in its range a given number of cycles after the first point was.
 \item \texttt{Eventually} delay, means that a hit will be considered if the second point is sampled in its range at any point within the following given number of cycles after the first point was.  
 \item \texttt{Always} delay, means that a hit will be considered if the second point is sampled in its range during every cycle for a given number of cycles after the first point was sampled.
\end{itemize}  

This thus concludes our discussion on Functional Coverage. We will now move on to presenting an industry provided use-case and show how our coverage solutions can be used to improve the testing efficiency of Chisel designs.

\section{Efficiency Evaluation}
As a way of evaluating our coverage solution in Scala, a use-case provided by Microchip was developed and verified using the functional coverage constructs presented in the previous section. It also gave the opportunity to assess how well a complete design process conducted only in Scala/Chisel works with the added features. The use-case is a heap-based priority queue which is meant to be used for scheduling purposes in real-time systems. Values referring to a specific clock cycle number in a specific super cycle can be inserted as well as removed. The priority queue sorts all enqueued values such that the value referring to the next clock cycle number that will be encountered is presented to the host system. 

The \textit{ChiselTest} framework was employed for testing (using a peek/poke/expect interface) and our functional coverage solution was used to verify the use-case. Defining the verification plan in Scala was done by defining a verification plan using the following structure:  
\begin{lstlisting}[language=scala]
val cr = new CoverageReporter(c)
cr.register(
CoverPoint(c.io.cmd.op, "operation")(
    Bins("insertion", 0 to 0) :: Bins("removal", 1 to 1) :: Nil) :: //More CoverPoints
    ) :: Nil)
\end{lstlisting}
In total we defined 5 \texttt{CoverPoints} each having up to 3 bins and 2 \texttt{CrossPoints} each having up to 5 cross bins. This was done in roughly 20 lines fully in scala, meaning that once the verification plan was defined, we could simply sample it directly inside of our \textit{ChiselTest} code without ever having to leave the Chisel/Scala world.

An other solution would have been to gather the functional coverage in SystemVerilog rather than in scala. This however means that Chisel testing frameworks, such as \textit{ChiselTest} could not have been used, since all of the testing would have to be done in SystemVerilog. For the sake of the argument, let's suppose that only the functional coverage gathering needed to be done in SystemVerilog, then the following would have had to be done in order to obtain the same result as our Scala-based solution:  
\begin{itemize}
    \item Create a UVM-subscriber based coverage class.
    \item Instantiate the current DUT (\texttt{priorityQueue pQ  = new;})
    \item Declare the verification plan: 
    \begin{lstlisting}[language=verilog]
covergroup unnamed;
	OPERATION: coverpoint pQ.cmd.op {
		bins insertion = {0};
		bins removal = {1};
		//More bins
	}
	//More coverpoints
endgroup: unnamed;
    \end{lstlisting}
    \item Define \texttt{build\_phase} and \texttt{write} functions.
    \item Define the coverage class constructor.
\end{itemize}  
All of this sums up to roughly 100 lines of code for the same result. So not only does our solution allow us to perform the entirety of our design and verification within the same ecosystem (moving to SystemVerilog would first require to generate Verilog from the Chisel design and then to simulate it using a SystemVerilog capable simulator like Verilator), but it also reduces the 5 step functional coverage process to a single step (defining the verification plan). It thus requires much less boiler plate code and reduces the total source code by a factor of 5.  

The Scala functional coverage solution presents itself as a natural addition to the \textit{ChiselTest} framework. One of the main advantages here was that the same language could be used for design and verification thus increasing the time effectiveness and removing a possible source of errors. Overall the use-case makes a strong point for hardware development in Scala/Chisel and all the possibilities that come with it. The coverage feature helps paving the way to a fully capable verification suite accompanying the Chisel language.

\section{Related work}
Our current coverage discussion proposes third party libraries  as solutions for gathering statement and functional coverage at multiple levels of abstraction. However, as we presented earlier, SystemVerilog, a mostly non-synthesisable extension of the Verilog HDL, contains certain constructs capable of gathering coverage information~\cite{spear2008systemverilog}. Developers of the Chisel language have thus been currently working on trying to make these constructs available directly in Chisel, which would allow them to be embedded in the language. This resulted in a \texttt{cover} statement being introduced in an experimental verification library as part of the Chisel 3.4.0 release~\cite{chisel3.4release_notes}. This \texttt{cover} statement was then given an equivalent at the FIRRTL level, which then maps down to SystemVerilog rather than plain Verilog. There is yet to be mainstream support for this new construct by FIRRTL execution engines like Treadle, which would explain why it remains experimental. Our solution greatly differs from this approach, since we try to utilise pre-existing language features from Chisel/Scala in order to enable coverage in the simplest possible manner. 

We defend the idea of reimplementing features from SystemVerilog in Scala (in Open-Source), rather than relying on the language itself, since it improves the overall cohesion of the Chisel-Scala ecosystem and removes the need to learn a language that has 250 key-words, thus saving the verification engineers time and improving overall efficiency of the verification process (which remains our main goal). Following that same idea, we will briefly mention the work conducted in parallel to the research presented in this paper, namely ChiselVerify~\cite{chiselverify}, our work on constructing a verification library, in Scala, that brings many features from SystemVerilog over to Chisel. The goal of the project is to allow for UVM style testing to be done on Chisel designs without having to rely SystemVerilog. 
\section{Conclusion}
We propose multiple solutions for the gathering of coverage data in high-level chisel designs. Previously, one needed to rely on other languages such as SystemVerilog in order obtain coverage information during the verification of a Chisel design. This meant that testing either fully needed to be done in an other language or we needed to turn to multi-language testing which was very often cumbersome and time-consuming. With our solutions we are bringing the world one step closer to making Chisel a fully capable design and verification language. We now no longer need to rely on other languages in order to gather statement and functional coverage of our Chisel designs. An interesting discussion to be had is around the abstraction-level that should be used to gather coverage. One could justify that high-level coverage information lacks usefulness when using hardware generators since we would rather have information on the execution of the generated hardware rather than the generator itself, but of course this discussion is left up for the reader to have. We also proposed a solution for functional coverage entirely in Scala, this is actually a small part of a much broader research project name ChiselVerify, done on bringing most aspects of design verification to the Chisel ecosystem.

\section{Acknowledgements}
We would like to thank the researchers at Berkeley who are constantly working on making Chisel a more ubiquitous hardware construction language and for the feedback related to our work on adding coverage to Treadle. We would also like to thank the members of the embedded systems section at DTU for providing a constantly stimulating environment and InfinIT for funding the project.

\bibliographystyle{abbrv}
\bibliography{coverage}


\end{document}
